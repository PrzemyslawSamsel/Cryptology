# Packages needed: PyQt5, pyQt5-stubs, qdarkstyle
import sys
from binascii import hexlify
from collections import namedtuple
from random import randint
from time import sleep

from PyQt5.QtCore import QRect, QSize, QPoint
from PyQt5 import QtCore
import PyQt5.QtCore as pqtc
from PyQt5.QtGui import QFont, QPalette, QColor, QPixmap
from PyQt5.QtWidgets import QApplication, QStyle, QVBoxLayout, QPushButton, QGridLayout, QGroupBox, QRadioButton, \
    QWidget, QHBoxLayout, QFrame, QLineEdit, QComboBox, QSpinBox, QCheckBox, QProgressBar, QDialog, QPlainTextEdit, \
    QTextBrowser, QDoubleSpinBox, QFileDialog
from PyQt5.QtWidgets import QLabel
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QStatusBar
from PyQt5.QtWidgets import QToolBar
from qdarkstyle import load_stylesheet
from LFSR import Galois, Fibonacci, XORSHIFT
from PRNG import PRNG
from Test import FIPS_TEST


class Window(QMainWindow):
    # Create groups that will be visible as sections in main window
    font_toolbar = QFont("Times", weight=QFont.Bold, pointSize=14)
    # Set of PRNGs to choose
    actions      = ['Geffe', 'Stop and Go', 'Shrinking']
    window_size  = (1000, 600)
    window_pos   = (800,  400)
    # Currently chosen generator
    current_action = 'Geffe'
    # Buttons (names and connected references to buttons - "ref") for PRNG
    generator_buttons = {"lfsr" : [{"name" : "LFSR-1", "ref" : None},
                                   {"name" : "LFSR-2", "ref" : None},
                                   {"name" : "LFSR-3", "ref" : None}],
                         "generate": {"name" : "Generate", "ref" : None},
                         "clear" : {"name" : "Clear", "ref" : None}} # <= reference to clear output button
    # Types of tests - for combobox and ranges
    test_types = {"Monobit": {"Name" : "Monobit", "Range": (9725, 10275)},
                  "Poker" : {"Name" : "Poker", "Range": (2.16, 46.17)} ,
                  "Long runs" : {"Name" : "Long runs", "Range": (26)}}
    # Reference to type box, range boxes, status box, value box and progress bar and button (start / clear)
    test_items = {"type-ref" : None, "len-ref" : None, "range-ref" : (None, None), "status-ref" : None, "value-ref" : None, "bar-ref" : None, 'button-ref': None}
    # Fields for type of Combobox for lfsr
    lsfr_items = ["Galois", "Fibonacci", "XORSHIFT"]
    # generated_output => out generated by PRNG
    # hex => hex representation of above (similarly dec)
    # state => True means already generating, False not generating
    out_fields = {"generated_output" : None,
                  "hex" : None,
                  "dec": None,
                  "state" : False,
                  'generated_output-val': '',  # reference to string containing output
                  "parameters" : {
                      "current" : None,    # Currently generated bit (iteration) <= function address
                      "current-value": 0,  # Currently generated bit (iteration) <= actual value
                      "limit"   : None, # Max generated bits (after this will stop) <= function address
                      "every"   : None, # Display output every n bits generated <= function address
                      "every_check":  None, # Display every n bits <= check box
                      "last"    : None, # Display n last bits of the output <= function address
                      "last_check": None,  # Display n last bits <= check box
                      "file_save" : None,
                      "animate_time" : None, # display next BIT after (ms) <= function address
                      "timer" : None, # timer object handler => just to stop and start timer in a particular moment
                      "bar-ref" : None, # reference to progress bar in Generator section
                  }}
    # Specifically for handling LFSRs
    register_fields = {
        "size-ref" : None, # reference to size spinbox
        "size": 4,  # reference to size spinbox
        "content-ref" : None, # reference to input of register content
        "content" : '1111', # actual content of register
        "tapmask-ref" : None, # reference to input of register tapmask
        "tapmask" : '1111', # actual tapmask of register
        "type-ref" : None, # type qcombobox
        "type"     : 'Galois', # actual type in string
        "confirm" : None, # Confirm Button reference
        "types-list"   : ["Galois", "Fibonacci", "XORSHIFT"] # Available register types
    }
    registers = [register_fields.copy(), register_fields.copy(), register_fields.copy()]

    def __init__(self, parent=None):
        """Initializer."""
        super(Window, self).__init__(parent)
        self.setWindowTitle('Pseudo Random Number Generator')
        #params:  move x, y size: x, y
        self.setStyleSheet(load_stylesheet(qt_api='pyqt5'))
        self.setGeometry(*Window.window_pos, *Window.window_size)
        self.setFixedSize(*Window.window_size)
        self._createMenu()
        self._createToolBar()
        self._createStatusBar()
        self._setCentralLayout()
    #

    def _createMenu(self):
        self.menu = self.menuBar().addMenu("&Menu")
        self.menuBar().addMenu("&Theme")
        self.menuBar().addMenu("&About")
        self.menu.addAction('&Exit', self.close)
    #

    def _createToolBar(self):
        tools = QToolBar()
        Geffe = tools.addAction(Window.actions[0], self._change_lfsr3_state)
        Geffe.setToolTip("Geffe Random Number Generator")
        Geffe.setFont(Window.font_toolbar)
        tools.addSeparator()
        StopGo = tools.addAction(Window.actions[1], self._change_lfsr3_state)
        StopGo.setToolTip("Stop&Go Random Number Generator")
        StopGo.setFont(Window.font_toolbar)
        tools.addSeparator()
        Shrinking = tools.addAction(Window.actions[2], self._change_lfsr3_state)
        Shrinking.setToolTip("Shrinking Random Number Generator")
        Shrinking.setFont(Window.font_toolbar)
        self.addToolBar(tools)
    #

    def _createStatusBar(self):
        self._status = QStatusBar()
        self._status.showMessage("")
        self.setStatusBar(self._status)
    #

    def _change_lfsr3_state(self):
        # Set name of currently chosen generator
        gen_name = self.sender().text()
        Window.current_action = gen_name
        lfsr3_button = Window.generator_buttons["lfsr"][2]["ref"]
        if gen_name == Window.actions[2]:
            lfsr3_button.setDisabled(True)
        else:
            lfsr3_button.setEnabled(True)


    def _lsfr_dialog(self):
        lfsr_id = self.sender().text().lstrip('LFSR-')
        lid = int(lfsr_id) - 1

        def get_random_content():
            Window.registers[lid]['content-ref'].setText(''.join([str(randint(0, 1)) for x in range(Window.registers[lid]['size-ref'].value())]))
        def get_random_tapmask():
            Window.registers[lid]['tapmask-ref'].setText(''.join([str(randint(0, 1)) for x in range(Window.registers[lid]['size-ref'].value())]))

        def confirmed():
            if Window.registers[lid]['content-ref'].text() != '':
                Window.registers[lid]['content'] = Window.registers[lid]['content-ref'].text()
            if Window.registers[lid]['tapmask-ref'].text() != '':
                Window.registers[lid]['tapmask'] = Window.registers[lid]['tapmask-ref'].text()
            Window.registers[lid]['type'] = Window.registers[lid]['type-ref'].currentText()
            Window.registers[lid]['size'] = Window.registers[lid]['size-ref'].value()
            d.close()

        # Initial settings for dialog
        d = QDialog()
        d.setStyleSheet(load_stylesheet(qt_api='pyqt5'))
        pos = self.pos()
        d.move(pos.x() + 100, pos.y() + 200)
        d.setWindowTitle("Dialog")
        d.setWindowModality(pqtc.Qt.ApplicationModal)
        #
        lfsr_grid = QGridLayout()
        # Size of register contents and tapmask
        size_label = QLabel("Size")
        size_box   = QSpinBox()
        Window.registers[lid]['size-ref'] = size_box
        size_box.setRange(1, 64)
        size_box.setValue(4)
        # Contents
        register_label = QLabel("Register contents")
        tapmask_label  = QLabel("Tapmask")
        register_cont  = QLineEdit() # maximum size of chosen size box!!!!
        Window.registers[lid]['content-ref'] = register_cont
        tapmask_cont   = QLineEdit()
        Window.registers[lid]['tapmask-ref'] = tapmask_cont
        register_gen   = QPushButton("Random")
        # # TODO: Random Primary Polynomial and check if primary
        tapmask_gen    = QPushButton("Random")
        #
        # # Type
        type_label     = QLabel("Type")
        type_box       = QComboBox()
        Window.registers[lid]['type-ref'] = type_box
        type_box.addItems(Window.registers[lid]['types-list'])
        # #
        cfrm = QPushButton("Confirm")
        Window.registers[lid]['confirm'] = cfrm
        #
        lfsr_grid.addWidget(size_label, *(0,0))
        lfsr_grid.addWidget(size_box, *(0,1))
        lfsr_grid.addWidget(register_label, *(2,0))
        lfsr_grid.addWidget(register_cont, *(3,0))
        lfsr_grid.addWidget(register_gen, *(3,1))
        lfsr_grid.addWidget(tapmask_label, *(4,0))
        lfsr_grid.addWidget(tapmask_cont, *(5,0))
        lfsr_grid.addWidget(tapmask_gen, *(5,1))
        lfsr_grid.addWidget(type_label, *(6,0))
        lfsr_grid.addWidget(type_box, *(6,1))
        lfsr_grid.addWidget(cfrm, *(7,1))
        # # # All widgets have been added - now to the logic:
        # Read actual contents first!
        contents = Window.registers[lid]['content']
        tapmask  = Window.registers[lid]['tapmask']
        type     = Window.registers[lid]['type']
        size      = Window.registers[lid]['size']
        # Set new values for the boxes
        type_box.setCurrentText(type) if type != "" else 0
        register_cont.setText(contents) if contents != "" else 0
        tapmask_cont.setText(tapmask) if tapmask != "" else 0
        size_box.setValue(size)
        # Contents read

        # Now setting connections of buttons
        cfrm.clicked.connect(confirmed)
        register_gen.clicked.connect(get_random_content)
        tapmask_gen.clicked.connect(get_random_tapmask)

        d.setLayout(lfsr_grid)
        d.exec_()
    #

    # Execute test
    def _start_test(self):
        if Window.test_items['button-ref'].text() == 'Start':
            self._status.showMessage("Testing...")
            Window.test_items['button-ref'].setText('Clear')
            lfsr_str = []
            # Create list of types of generators
            if Window.generator_buttons["lfsr"][2]["ref"].isEnabled():
                lfsr_str.extend([Window.registers[0]['type'],
                Window.registers[1]['type'],
                Window.registers[2]['type']])
            else:
                lfsr_str.extend([Window.registers[0]['type'],
                                 Window.registers[1]['type']])

            # Map types to objects
            lfsr = []
            for reg in lfsr_str:
                if reg == 'Galois':
                    lfsr.append(Galois)
                elif reg == 'Fibonacci':
                    lfsr.append(Fibonacci)
                elif reg == 'XORSHIFT':
                    lfsr.append(XORSHIFT)

            # Get currently chosen generator
            gen = None
            if Window.current_action == Window.actions[0]:
                gen = PRNG.Geffe
            elif Window.current_action == Window.actions[1]:
                gen = PRNG.StopAndGo
            elif Window.current_action == Window.actions[2]:
                gen = PRNG.Shrinking

            # Get registers initial values
            params_cont = []
            params_tapm = []
            for i, reg in enumerate(lfsr):
                params_cont.append(Window.registers[i]['content'])
                params_tapm.append(Window.registers[i]['tapmask'])

            # Create test object
            params = [params_cont, params_tapm]
            test_obj = FIPS_TEST(gen=gen, lfsr=lfsr, params=params)

            # Ten % of test finished
            Window.test_items['bar-ref'].setValue(10)

            test_params = None
            # Set function test to proper object and set test_params
            if Window.test_items['type-ref'].currentText() == Window.test_types['Monobit']['Name']:
                test = test_obj.monobit
                test_params = (Window.test_items['range-ref'][0].value(),
                               Window.test_items['range-ref'][1].value()
                )
            elif Window.test_items['type-ref'].currentText() == Window.test_types['Poker']['Name']:
                test = test_obj.poker
                test_params = (Window.test_items['range-ref'][0].value(),
                               Window.test_items['range-ref'][1].value()
                               )
            elif Window.test_items['type-ref'].currentText() == Window.test_types['Long runs']['Name']:
                test = test_obj.long_runs
                test_params = Window.test_items['range-ref'][0].value()

            # Generate sequence for the tests
            sequence = ''
            test_bar = 10
            for x in range(Window.test_items['len-ref'].value()):
                sequence += next(test_obj.gen)
                test_bar += 1
                Window.test_items['bar-ref'].setValue(test_bar)

            test_obj.sequence = sequence

            # Execute tests
            status, value = test(thresholds=test_params)
            Window.test_items['bar-ref'].setValue(100)

            # Set values
            Window.test_items['value-ref'].setText(str(value))

            if status:
                Window.test_items['status-ref'].setPixmap(QPixmap("pass.png").scaled(50, 400, pqtc.Qt.KeepAspectRatio))
            else:
                Window.test_items['status-ref'].setPixmap(QPixmap("fail.png").scaled(50, 400, pqtc.Qt.KeepAspectRatio))
        else:
            # Clear test fields
            Window.test_items['button-ref'].setText('Start')
            Window.test_items['status-ref'].setPixmap(QPixmap("none.png").scaled(50, 400, pqtc.Qt.KeepAspectRatio))
            Window.test_items['value-ref'].setText('')
            Window.test_items['bar-ref'].setValue(0)
    #

    def _setCentralLayout(self):
        grid = QGridLayout()
        centralWidget = QWidget()

        def generator_group():
            widgets_view = []
            # Frame that will hold horizontal buttons layout
            lfsr_button_frame = QFrame()

            # Add label "LFSR: "
            widgets_view.append(QLabel("LFSR: "))
            # Create horizontal layout
            horzlay = QHBoxLayout()
            # Append LFSR buttons to it
            for bt in Window.generator_buttons["lfsr"]:
                button = QPushButton(bt["name"])
                button.clicked.connect(self._lsfr_dialog)
                button.setToolTip("Click to set properties for register " + bt["name"].lstrip("&"))
                horzlay.addWidget(button)
                bt["ref"] = button
            horzlay.addStretch()
            # Add layout to frame
            lfsr_button_frame.setLayout(horzlay)
            # Append frame to widgets
            widgets_view.append(lfsr_button_frame)

            # Append second "Parameters: " label to widgets
            # Create grid for Parameters region
            widgets_view.append(QLabel("Parameters: "))
            params_grid = QGridLayout()

            # First parameter - number of bits to generate by generator
            nr_bits_box       = QSpinBox()
            nr_bits_box.setRange(10, 10000)
            count_bits_label = QLabel("Bits count")
            nr_bits_box.setToolTip("Number of bits to generate")
            Window.out_fields['parameters']['limit'] = nr_bits_box

            # Second param - display these bits every n bits generated
            display_every_box = QSpinBox()
            display_every_check = QCheckBox()
            display_every_check.setText("Bits (shown) interval")
            display_every_box.setRange(10, 10000) # Should it have any special range?
            display_every_box.setToolTip("After how many bits should the tool display output")
            Window.out_fields['parameters']['every'] = display_every_box
            Window.out_fields['parameters']['every_check'] = display_every_check

            # Second param - display last generated bits
            display_last_box    = QSpinBox()
            display_last_check  = QCheckBox()
            display_last_check.setText("Last (shown) bits")
            display_last_box.setRange(10, 10000)  # Should it have any special range?
            display_last_box.setToolTip("Display n last bits of output")
            Window.out_fields['parameters']['last'] = display_last_box
            Window.out_fields['parameters']['last_check'] = display_last_check

            # Third section - add to file, animate etc. - aux options
            save_to_file_box = QCheckBox()
            save_to_file_box.setText("Save to file")
            save_to_file_box.setToolTip("Click to save to file (dialog will appear after Generate button clicked)")
            Window.out_fields['parameters']['file_save'] = save_to_file_box
            animate_check = QLabel("Animate (ms)")
            animate_box   = QSpinBox()
            animate_box.setToolTip("Animation interval in milliseconds")
            animate_box.setRange(10, 10000)
            animate_box.setValue(500)
            Window.out_fields['parameters']['animate_time'] = animate_box

            # Add all sections to the grid
            params_grid.addWidget(count_bits_label, *(0,0))
            params_grid.addWidget(nr_bits_box, *(0, 1))

            params_grid.addWidget(animate_check, *(1, 0))
            params_grid.addWidget(animate_box, *(1, 1))

            params_grid.addWidget(display_last_check, *(2, 0))
            params_grid.addWidget(display_last_box, *(2, 1))

            params_grid.addWidget(save_to_file_box, *(3, 0))

            params_grid.addWidget(display_every_check, *(4, 0))
            params_grid.addWidget(display_every_box, *(4, 1))


            # Add all sections to the grid
            # Create frame and add grid to it, next add frame to widgets
            f3 = QFrame()
            f3.setLayout(params_grid)
            widgets_view.append(f3)

            # Append third "Out: " layout to widgets
            gen_lay = QHBoxLayout()
            gen_lay.addWidget(QLabel("Output: "))
            generate_button = QPushButton(Window.generator_buttons['generate']['name'])
            Window.generator_buttons['generate']['ref'] = generate_button
            generate_button.clicked.connect(self.fgenerate_button)
            gen_lay.addWidget(generate_button)
            f4 = QFrame()
            f4.setLayout(gen_lay)
            widgets_view.append(f4)

            # Append Fourth section "Generated output holder" to widgets
            generated_output = QTextBrowser()
            generated_output.setMinimumHeight(50)
            generated_output.setMaximumHeight(50)
            generated_output.setToolTip("Right click on window and Select All / Copy to get output to clipboard")
            generated_output.setReadOnly(True)
            Window.out_fields['generated_output'] = generated_output
            generated_output.textChanged.connect(self.conversion_out)
            horzlay_out = QHBoxLayout()
            horzlay_out.addWidget(generated_output)

            # Append frame to widgets
            f2 = QFrame()
            f2.setLayout(horzlay_out)
            widgets_view.append(f2)


            # Fifth section - hex and dec values of output window
            horzlay_conv = QHBoxLayout()

            dec_label = QLabel("dec")
            hex_label = QLabel("hex")
            dec_box = QLineEdit()
            dec_box.setFixedSize(170, 20)
            dec_box.setToolTip("Right click on window and Select All / Copy to get output to clipboard")
            dec_box.setReadOnly(True)
            Window.out_fields["dec"] = dec_box
            hex_box = QLineEdit()
            hex_box.setFixedSize(170, 20)
            hex_box.setToolTip("Right click on window and Select All / Copy to get output to clipboard")
            hex_box.setReadOnly(True)
            Window.out_fields["hex"] = hex_box
            horzlay_conv.addWidget(dec_label)
            horzlay_conv.addWidget(dec_box)
            horzlay_conv.addWidget(hex_label)
            horzlay_conv.addWidget(hex_box)

            f3 = QFrame()
            f3.setLayout(horzlay_conv)
            widgets_view.append(f3)

            # Fifth section
            progress_bar = QProgressBar()
            progress_bar.setValue(0)
            progress_bar.setTextVisible(True)
            progress_txt = "%p%".format(0)
            progress_bar.setFormat(progress_txt)
            progress_bar.setAlignment(pqtc.Qt.AlignCenter)
            widgets_view.append(progress_bar)
            Window.out_fields['bar-ref'] = progress_bar

            return widgets_view
        #

        def test_group():
            # This function just sets default values for ranges of types of tests
            # And additionally disables second range for "Long runs" test
            def test_type_ranges():
                if Window.test_items['type-ref'].currentText() == Window.test_types['Monobit']['Name']:
                    if Window.test_items['range-ref'][1] != None:
                        if not Window.test_items['range-ref'][1].isEnabled():
                            Window.test_items['range-ref'][1].setDisabled(False)
                        Window.test_items['range-ref'][0].setValue(int(Window.test_types['Monobit']['Range'][0]))
                        Window.test_items['range-ref'][1].setValue(int(Window.test_types['Monobit']['Range'][1]))
                    if Window.test_items['value-ref'] != None:
                        Window.test_items['value-ref'].setToolTip("Number of 1's in generated output")
                elif Window.test_items['type-ref'].currentText() == Window.test_types['Poker']['Name']:
                    if Window.test_items['range-ref'][1] != None:
                        if not Window.test_items['range-ref'][1].isEnabled():
                            Window.test_items['range-ref'][1].setDisabled(False)
                        Window.test_items['range-ref'][0].setValue(Window.test_types['Poker']['Range'][0])
                        Window.test_items['range-ref'][1].setValue(Window.test_types['Poker']['Range'][1])
                    if Window.test_items['value-ref'] != None:
                        Window.test_items['value-ref'].setToolTip("Statistical calculation of specific 4-bit chunks appearing in entire test")
                elif Window.test_items['type-ref'].currentText() == Window.test_types['Long runs']['Name']:
                    if Window.test_items['range-ref'][1] != None:
                        if Window.test_items['range-ref'][1].isEnabled():
                            Window.test_items['range-ref'][1].setEnabled(False)
                        Window.test_items['range-ref'][0].setValue(int(Window.test_types['Long runs']['Range']))
                    if Window.test_items['value-ref'] != None:
                        Window.test_items['value-ref'].setToolTip("Largest length of a sequence appearing in generated output")
            #
            widgets_view = []
            test_frame = QFrame()

            # Create horizontal layout
            test_param_box = QGridLayout()
            # Type of test
            type_label     = QLabel("Type")
            type_box       = QComboBox()
            type_box.currentIndexChanged.connect(test_type_ranges)
            Window.test_items['type-ref'] = type_box
            type_box.addItems([type for type in Window.test_types.keys()])

            len_label = QLabel("Length")
            # Minimum value
            len_box = QSpinBox()
            len_box.setToolTip("Length of string generated for the test")
            len_box.setRange(-100000, 100000)
            len_box.setValue(20000)
            Window.test_items['len-ref'] = len_box

            # Parameters of the test - range of values
            param_label = QLabel("Test range")
            # Minimum value
            param_from = QDoubleSpinBox()
            param_from.setToolTip("Minimum value for the test to pass")
            param_from.setRange(-100000.0, 100000.0)
            param_from.setValue(Window.test_types['Monobit']['Range'][0])
            # Maximum value
            param_to = QDoubleSpinBox()
            param_to.setToolTip("Minimum value for the test to pass")
            param_to.setRange(-100000.0, 100000.0)
            param_to.setValue(Window.test_types['Monobit']['Range'][1])
            Window.test_items['range-ref'] = (param_from, param_to)
            #

            # Test value and status
            ret_label = QLabel("Test value")
            status_label = QLabel("Test status")
            returned_status = QLabel()
            returned_status.setPixmap(QPixmap("none.png").scaled(50, 400, pqtc.Qt.KeepAspectRatio))
            Window.test_items['status-ref'] = returned_status
            # Test value returned
            test_val = QLineEdit()
            test_val.setFixedSize(120, 20)
            test_val.setToolTip("Right click on window and Select All / Copy to get output to clipboard")
            test_val.setReadOnly(True)
            Window.test_items['value-ref'] = test_val
            start_test = QPushButton("Start")
            start_test.clicked.connect(self._start_test)
            Window.test_items['button-ref'] = start_test
            #

            # Add type of test
            test_param_box.addWidget(type_label, *(0,0))
            test_param_box.addWidget(type_box,   *(0,1))
            # Length of string for the test
            test_param_box.addWidget(len_label, *(1, 0))
            test_param_box.addWidget(len_box, *(1, 1))
            # Add test parameters and range
            test_param_box.addWidget(param_label,*(2,0))
            test_param_box.addWidget(param_from,*(2,1))
            test_param_box.addWidget(param_to,*(2,2))
            # Test status and value
            test_param_box.addWidget(status_label, *(3, 0))
            test_param_box.addWidget(returned_status,*(3,1))
            test_param_box.addWidget(ret_label, *(4, 0))
            test_param_box.addWidget(test_val, *(4, 1))
            test_param_box.addWidget(start_test, *(4, 3))

            test_frame.setLayout(test_param_box)
            widgets_view.append(test_frame)


            test_progress = QProgressBar()
            test_progress.setValue(0)
            test_progress.setTextVisible(True)
            progress_txt = "%p%".format(0)
            test_progress.setFormat(progress_txt)
            Window.test_items['bar-ref'] = test_progress
            widgets_view.append(test_progress)

            return widgets_view
        #

        # group structure template
        gt = namedtuple("Group", ["box", "layout", "widgets", "pos"])
        groups = (gt(box=QGroupBox("Generator"), layout=QVBoxLayout(), widgets=[], pos=(0, 0)),
                  gt(box=QGroupBox("Tests"), layout=QVBoxLayout(), widgets=[], pos=(0, 1)))

        # Assign widgets to Generator section
        groups[0].widgets.extend(generator_group())
        groups[1].widgets.extend(test_group())

        # Define widgets and layouts for each group
        # Assign all groups to a grid
        for g in groups:
            for w in g.widgets:
                g.layout.addWidget(w)
            g.layout.addStretch()
            g.box.setLayout(g.layout)
            grid.addWidget(g.box, *g.pos)

        centralWidget.setLayout(grid)
        self.setCentralWidget(centralWidget)
    #

    # Functions related to back-end logic - how buttons work etc.
    # Disable button, create prng, call it, enable button
    # In general - handles "Generate" button action
    def fgenerate_button(self):
        # This runs if user clicks button "Generate"
        if Window.generator_buttons['generate']['ref'].text() == Window.generator_buttons['generate']['name']:
            # Updating Output (generated) field
            def out_generate_update():
                # If limit not reached
                if Window.out_fields['parameters']['current-value'] <= limit:
                    # Increment value and progress bar value
                    Window.out_fields['parameters']['current-value'] += 1
                    Window.out_fields['bar-ref'].setValue(Window.out_fields['parameters']['current-value'] * (100 // Window.out_fields['parameters']['limit'].value()))
                    # Generate and output next bit, increment
                    Window.out_fields['generated_output-val'] += next(prng)

                    # If every n bits option is check and
                    # length of generated output is not a multiple of desired parameter - then skip printing output
                    if Window.out_fields['parameters']['every_check'].isChecked():
                        print(len(Window.out_fields['generated_output-val']), " : ",len(Window.out_fields['generated_output-val']) % Window.out_fields['parameters']['every'].value())
                        if len(Window.out_fields['generated_output-val']) < Window.out_fields['parameters']['every'].value():
                            return
                        if len(Window.out_fields['generated_output-val']) % Window.out_fields['parameters']['every'].value() != 0:
                            return

                    # Set output value
                    if Window.out_fields['parameters']['last_check'].isChecked():
                        Window.out_fields['generated_output'].setPlainText(Window.out_fields['generated_output-val'][-Window.out_fields['parameters']['last'].value():])
                    else:
                        Window.out_fields['generated_output'].setPlainText(Window.out_fields['generated_output-val'])
                else:
                    # Stop timer
                    Window.generator_buttons['generate']['ref'].setText('Generate')
                    Window.out_fields['bar-ref'].setValue(0)
                    timer.stop()
                    if Window.out_fields['parameters']['file_save'].isChecked():
                        name, _ = QFileDialog.getSaveFileName(self, 'Save File')
                        print(name)
                        file = open(name, 'w')
                        file.write(Window.out_fields['generated_output-val'])
                        file.close()
            #
            Window.out_fields['generated_output-val'] = ''
            Window.out_fields['generated_output'].setPlainText(
                Window.out_fields['generated_output-val'])
            # Set button text to "Stop"
            Window.generator_buttons['generate']['ref'].setText('Stop')
            # Create new PRNG based on parameters

            lfsr_str = []
            # Create list of types of generators
            if Window.generator_buttons["lfsr"][2]["ref"].isEnabled():
                lfsr_str.extend([Window.registers[0]['type'],
                                 Window.registers[1]['type'],
                                 Window.registers[2]['type']])
            else:
                lfsr_str.extend([Window.registers[0]['type'],
                                 Window.registers[1]['type']])

            # Map types to objects
            lfsr = []
            for reg in lfsr_str:
                if reg == 'Galois':
                    lfsr.append(Galois)
                elif reg == 'Fibonacci':
                    lfsr.append(Fibonacci)
                elif reg == 'XORSHIFT':
                    lfsr.append(XORSHIFT)

            # Get currently chosen generator
            gen = None
            if Window.current_action == Window.actions[0]:
                gen = PRNG.Geffe
            elif Window.current_action == Window.actions[1]:
                gen = PRNG.StopAndGo
            elif Window.current_action == Window.actions[2]:
                gen = PRNG.Shrinking

            # Get registers initial values
            params_cont = []
            params_tapm = []
            for i, reg in enumerate(lfsr):
                params_cont.append(Window.registers[i]['content'])
                params_tapm.append(Window.registers[i]['tapmask'])


            prng = PRNG(iS=params_cont, tm=params_tapm, LFSR=lfsr, gen=gen).get_generator()
            # Set current iteration on 1
            Window.out_fields['parameters']['current-value'] = 1
            # Get limit of iterations
            limit   = Window.out_fields['parameters']['limit'].value()
            # Start timer and connect it to function
            timer = pqtc.QTimer()
            timer.timeout.connect(out_generate_update)
            Window.out_fields['parameters']['timer'] = timer
            # Set timeout based on parameters and start timer
            timer.start(Window.out_fields['parameters']['animate_time'].value())
            self._status.showMessage("Generating...")
        # This runs if user clicks button "Stop"
        else:
            Window.generator_buttons['generate']['ref'].setText('Generate')
            Window.out_fields['parameters']['timer'].stop()
            Window.out_fields['bar-ref'].setValue(0)
            self._status.showMessage("")
    #

    def conversion_out(self):
        if Window.out_fields['generated_output'].toPlainText() != '':
            val = Window.out_fields['generated_output'].toPlainText()
            val_dec = str(int(val, 2))
            val_hex = "0x" + hex(int(val, 2)).lstrip("0x").upper()
            Window.out_fields['dec'].setText(val_dec)
            Window.out_fields['hex'].setText(val_hex)
    #
#


if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = Window()
    win.show()
    sys.exit(app.exec_())